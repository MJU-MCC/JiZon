package ThreeWeek.Jooyeon;

public class OperatorExample {
    public static void main(String[] args) {

        /*

        산술 변환이란 ? 연산 수행 직전에 밟생하는 피연산자의 자동 형변환

        1. 두 피연산자의 타입을 같게 일치시킨다 (보다 큰 타입으로 일치)
        2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

         */


        char c1 = 'd';
        //char c2 = c1+1; //컴파일 에러 발생
        char c2 = 'd' + 1; /// 컴파일 에러 없음

      //  System.out.println("c2의 값: " +c2);


        /*

        위의 산술 변환의 정의에 따르면 보다 큰 타입으로 일치시키는 것 (char형보다 int형이 더 큰 타입이므로 int형으로 변환되는 것)이 정상이지만

        (산술 변환의 정의에 따르면 char형인 'd'가 + 1을 수행하게 되면 큰 타입인 int형으로 자동 형변환되어
         100+1, 101의 int형으로 char형인 c2에 저장되므로 컴파일 에러가 발생되어야 한다.)


        그러나 해당 연산은 컴파일 에러가 발생하지 않는다.
        'd' + 1은 리터럴 간의 연산이므로 컴파일러가 미리 계산을 하기 때문에 컴파일 에러가 발생하지 않는다.
        상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니다.

        그래서 실행 시에는 덧셈 연산이 수행되지 않는다. (컴파일러가 미리 덧셈연산 수행)
        덧셈 연산 결과인 문자 'e'를 c2 변수에 저장하게 되므로 컴파일 에러가 발생하지 않는다.

        하지만 17번째 줄 코드인 c1 + 1 같은 경우에는 컴파일 에러가 발생하게 된다.
        수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 수행할 수 없다.
        이 경우에는 char c2 = (char)(c1 + 1) 과 같이 형변환을 진행해주어야 컴파일 에러가 발생하지 않게 된다.

        */

    }
}
